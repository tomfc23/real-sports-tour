<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karma League Live Scores 3</title>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <style>
    :root {
      --bg-color: #1a001a;
      --card-color: #2e0033;
      --accent-color: #b366ff;
      --text-color: #e0d9ff;
      --text-muted: #9a7eff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      padding: 24px;
      max-width: 760px;
      margin: auto;
    }

    h1 {
      text-align: center;
      font-size: 32px;
      margin-bottom: 16px;
      color: var(--accent-color);
    }

    #loading-indicator {
      text-align: center;
      font-size: 14px;
      color: var(--accent-color);
      margin-bottom: 16px;
    }

    .bracket {
      background-color: var(--card-color);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 24px;
      box-shadow: 0 0 15px rgba(179,102,255,0.4);
    }

    .bracket h2 {
      margin-bottom: 12px;
      border-bottom: 1px solid var(--accent-color);
      padding-bottom: 6px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    thead tr {
      border-bottom: 2px solid var(--accent-color);
    }

    th, td {
      text-align: left;
      padding: 8px 6px;
      color: var(--text-color);
    }

    tbody tr:nth-child(odd) {
      background-color: #3a004d;
    }

    tbody tr[style*="opacity:0.4"] {
      opacity: 0.4;
    }
  </style>
</head>
<body>
  <h1>Karma League Live Scores</h1>
  <div id="loading-indicator">Loading...</div>
  <div id="leaderboard-container"></div>

<script>
const WORKER_URL = 'https://rst.tomfconreal.workers.dev/';
const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ5_4iMe0s46WHziXgAcLGkS7VFMBaNLXndPcpT20b7YSaUTRz_2BTr6NC24XlRF3oHSZAm2fi-RrHV/pub?output=csv';

// Cache karma fetches per userId
const karmaCache = new Map();
const concurrencyLimit = 10;

function getESTDayBounds() {
  // Returns 5 timestamps in seconds UTC of 7AM EST for Thu, Fri, Sat, Sun, Mon boundaries.
  // Tournament Thu-Sun days start at 7AM EST (UTC-4 or UTC-5 with DST). 
  // We'll create Date objects at 7AM EST for the relevant days and convert to UTC timestamps in seconds.
  // Assumes EST is always UTC-4 here for simplicity (adjust if DST matters).
  const estOffset = -4 * 3600; // seconds offset from UTC
  const now = new Date();

  // Get today's date in EST timezone by shifting UTC by offset
  const utcYear = now.getUTCFullYear();
  const utcMonth = now.getUTCMonth();
  const utcDate = now.getUTCDate();

  // We'll find the Thursday of this week (or nearest past Thu if today after Thu)
  // Date of nearest Thursday relative to today:
  const dayOfWeek = now.getUTCDay(); // 0=Sun, 1=Mon ... 4=Thu ...
  // Find offset to Thursday (4)
  let diffToThu = 4 - dayOfWeek;
  if (diffToThu > 0) diffToThu -= 7; // ensure Thursday in past week or today

  // Thu Date UTC
  const thuDate = new Date(Date.UTC(utcYear, utcMonth, utcDate + diffToThu));

  // Helper: create 7AM EST Date UTC timestamp seconds for given date
  function sevenAmEst(date) {
    // 7 AM EST in UTC = 7 AM + 4 hours = 11AM UTC
    // So set UTC hours to 11
    return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 11, 0, 0) / 1000;
  }

  // Calculate boundaries Thu, Fri, Sat, Sun, Mon at 7AM EST
  const thu = sevenAmEst(thuDate);
  const fri = thu + 86400;
  const sat = fri + 86400;
  const sun = sat + 86400;
  const mon = sun + 86400;

  return [thu, fri, sat, sun, mon];
}

function calculateMedian(arr) {
  if (!arr.length) return 0;
  const sorted = arr.slice().sort((a,b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 !== 0) return sorted[mid];
  return (sorted[mid - 1] + sorted[mid]) / 2;
}

// Parse CSV from Google Sheets
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  return lines.slice(1).map(line => {
    const values = line.split(',').map(v => v.trim());
    const obj = {};
    headers.forEach((h,i) => obj[h] = values[i]);
    return obj;
  });
}

// Fetch karma data for one userId with caching and cache busting (add timestamp param)
async function fetchKarma(userId) {
  if (karmaCache.has(userId)) return karmaCache.get(userId);
  try {
    const url = `${WORKER_URL}?userId=${encodeURIComponent(userId)}&cb=${Date.now()}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    // data.items expected: array of events with createdAt and amount
    if (!data.items || !Array.isArray(data.items)) return [];
    karmaCache.set(userId, data.items);
    return data.items;
  } catch (e) {
    console.warn(`Failed fetching karma for ${userId}: ${e}`);
    return [];
  }
}

// Bucket karmafeed events into day sums based on EST 7AM day boundaries
function bucketKarmaByDay(karmafeed) {
  const [thu, fri, sat, sun, mon] = getESTDayBounds();
  const scores = { thursday: 0, friday: 0, saturday: 0, sunday: 0 };
  if (!Array.isArray(karmafeed)) return scores;

  for (const entry of karmafeed) {
    if (!entry.createdAt || entry.amount == null) continue;
    const eventDate = new Date(entry.createdAt);
    const eventTs = eventDate.getTime() / 1000; // seconds UTC
    const delta = Number(entry.amount) || 0;
    if (eventTs >= thu && eventTs < fri) scores.thursday += delta;
    else if (eventTs >= fri && eventTs < sat) scores.friday += delta;
    else if (eventTs >= sat && eventTs < sun) scores.saturday += delta;
    else if (eventTs >= sun && eventTs < mon) scores.sunday += delta;
  }
  Object.keys(scores).forEach(k => scores[k] = Math.round(scores[k]));
  return scores;
}

// Concurrency helper: limit concurrency of async calls
async function limitedMap(arr, limit, asyncFn, onProgress) {
  const results = [];
  let index = 0;
  const executing = new Set();

  for (const item of arr) {
    const p = asyncFn(item).then(res => {
      results.push(res);
      if (onProgress) onProgress(++index, arr.length);
    });
    executing.add(p);
    p.finally(() => executing.delete(p));
    if (executing.size >= limit) await Promise.race(executing);
  }
  await Promise.all(executing);
  return results;
}

async function loadLeaderboard() {
  const loading = document.getElementById('loading-indicator');
  const container = document.getElementById('leaderboard-container');
  loading.textContent = 'Loading CSV...';

  try {
    // Load users CSV: user @,user id ,seed ,status
    const csvRes = await axios.get(`${CSV_URL}?cb=${Date.now()}`);
    const usersRaw = parseCSV(csvRes.data)
      .filter(u => u.status?.toLowerCase() === 'active')
      .map(u => ({
        userAt: u['user @'],
        userId: u['user id'],
        seed: u.seed?.toLowerCase() === 'pro' ? 'pro' : 'amatuer',
        scores: {}, sum: 0, qualified: true, karmafeed: []
      }));

    loading.textContent = `Fetching karma for ${usersRaw.length} users...`;

    let loadedCount = 0;
    function updateProgress() {
      loading.textContent = `Loaded karma for ${loadedCount++} of ${usersRaw.length} users...`;
    }

    // Fetch karmafeeds concurrently with limit
    const karmaArrays = await limitedMap(usersRaw, concurrencyLimit, async u => {
      const feed = await fetchKarma(u.userId);
      updateProgress();
      return feed;
    });

    // Attach karmafeed and daily sums
    usersRaw.forEach((u, i) => {
      u.karmafeed = karmaArrays[i];
      u.scores = bucketKarmaByDay(u.karmafeed);
    });

    // Determine tournament phase and cutoff logic
    // Phase day sums to use for final sum
    // Thu & Fri sums used for cutoff
    // Sum full Thu-Sun for final sum after cutoff

    const [thu, fri, sat, sun] = getESTDayBounds();
    const nowSec = Date.now() / 1000;

    // Phase info and cutoffActive
    let cutoffActive = false;
    if (nowSec >= fri && nowSec < mon) cutoffActive = true;

    // Compute initial sums for cutoff calc (Thu+Fri)
    usersRaw.forEach(u => {
      u.sum = (u.scores.thursday || 0) + (u.scores.friday || 0);
    });

    if (cutoffActive) {
      // Calculate median cutoff per bracket
      const amatuer = usersRaw.filter(u => u.seed === 'amatuer');
      const pro = usersRaw.filter(u => u.seed === 'pro');

      const amatuerMedian = calculateMedian(amatuer.map(u => u.sum));
      const proMedian = calculateMedian(pro.map(u => u.sum));

      // Mark qualified above median
      amatuer.forEach(u => { u.qualified = u.sum > amatuerMedian; });
      pro.forEach(u => { u.qualified = u.sum > proMedian; });

      // For qualified users, sum Thu-Sun karma, else zero
      usersRaw.forEach(u => {
        if (u.qualified) {
          u.sum = (u.scores.thursday || 0) + (u.scores.friday || 0) + (u.scores.saturday || 0) + (u.scores.sunday || 0);
        } else {
          u.sum = 0;
        }
      });
    } else {
      // Before cutoff day: show live karmaDelta for today only (Sunday uses sunday karma only)
      const todaySec = nowSec;
      // We'll detect current EST day bucket by comparing now to boundaries:
      // Show karma only for the current EST day
      // fallback to Thursday bucket for safety
      let currentBucket = 'thursday';
      if (nowSec >= thu && nowSec < fri) currentBucket = 'thursday';
      else if (nowSec >= fri && nowSec < sat) currentBucket = 'friday';
      else if (nowSec >= sat && nowSec < sun) currentBucket = 'saturday';
      else if (nowSec >= sun && nowSec < mon) currentBucket = 'sunday';

      usersRaw.forEach(u => {
        u.sum = u.scores[currentBucket] || 0;
        u.qualified = true;
      });
    }

    // Sort each bracket descending sum, then username ascending
    const amatuerUsers = usersRaw.filter(u => u.seed === 'amatuer').sort((a,b) => b.sum - a.sum || a.userAt.localeCompare(b.userAt));
    const proUsers = usersRaw.filter(u => u.seed === 'pro').sort((a,b) => b.sum - a.sum || a.userAt.localeCompare(b.userAt));

    function renderBracket(title, users) {
      let html = `<div class="bracket"><h2>${title}</h2><table><thead><tr><th>Rank</th><th>User</th><th>Karma</th></tr></thead><tbody>`;
      let rank = 0;
      for (const u of users) {
        rank++;
        html += `<tr${u.qualified ? '' : ' style="opacity:0.4"'}><td>${rank}</td><td>@${u.userAt}</td><td>${u.sum}</td></tr>`;
      }
      html += '</tbody></table></div>';
      return html;
    }

    container.innerHTML = renderBracket('Amateur Bracket', amatuerUsers) + renderBracket('Pro Bracket', proUsers);
    loading.textContent = `Loaded karma for ${usersRaw.length} users.`;
  } catch (e) {
    console.error(e);
    document.getElementById('loading-indicator').textContent = 'Error loading leaderboard.';
  }
}

// Initial load + refresh every 5 minutes
loadLeaderboard();
setInterval(() => {
  karmaCache.clear(); // clear cache to fetch fresh data
  loadLeaderboard();
}, 5 * 60 * 1000);
</script>
</body>
</html>
