<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Karma League Live Scores 2</title>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<style>
  :root {
    --bg-color: #0a0a17;
    --card-color: #1a0f3d;
    --accent-color: #9a4dff;
    --text-color: #e0d9ff;
    --text-muted: #8a79a3;
    --table-border: #3a2f66;
  }
  body {
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Segoe UI', Roboto, sans-serif;
    max-width: 760px;
    margin: auto;
    padding: 24px;
  }
  h1 {
    text-align: center;
    margin-bottom: 24px;
  }
  .loading {
    color: var(--accent-color);
    margin-bottom: 16px;
    text-align: center;
  }
  .bracket {
    margin-bottom: 40px;
  }
  .bracket h2 {
    border-bottom: 2px solid var(--accent-color);
    padding-bottom: 6px;
    margin-bottom: 12px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    background-color: var(--card-color);
    border: 1px solid var(--table-border);
    border-radius: 6px;
    overflow: hidden;
  }
  th, td {
    text-align: left;
    padding: 8px 12px;
    border-bottom: 1px solid var(--table-border);
  }
  th {
    color: var(--accent-color);
  }
  tbody tr:hover {
    background-color: #3a2f66;
  }
  .footer {
    text-align: center;
    margin-top: 32px;
    font-size: 14px;
    color: var(--text-muted);
  }
</style>
</head>
<body>
<h1>Karma League Live Scores</h1>
<div class="loading" id="loading-indicator">Loading...</div>
<div id="leaderboard"></div>
<div class="footer">Auto-refreshes every 5 minutes</div>

<script>
const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ5_4iMe0s46WHziXgAcLGkS7VFMBaNLXndPcpT20b7YSaUTRz_2BTr6NC24XlRF3oHSZAm2fi-RrHV/pub?output=csv';
const WORKER_URL = 'https://rst.tomfconreal.workers.dev/';
const CONCURRENCY = 10;

// Utility: parse CSV text to array of objects
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  return lines.slice(1).map(line => {
    const values = line.split(',').map(p => p.trim());
    const obj = {};
    headers.forEach((h, i) => obj[h] = values[i]);
    return obj;
  });
}

// Get EST midnight 7AM time boundaries for Thu-Sun ranges as unix timestamps (seconds)
function getESTDayBounds() {
  const now = new Date();
  const nowEst = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
  const estDay = nowEst.getDay();
  const today7amEst = new Date(nowEst);
  today7amEst.setHours(7,0,0,0);
  let daysSinceThursday = estDay - 4;
  if (daysSinceThursday < 0) daysSinceThursday += 7;
  if (estDay === 4 && nowEst < today7amEst) {
    daysSinceThursday = 7;
  }
  const thursday7amEst = new Date(nowEst);
  thursday7amEst.setHours(7,0,0,0);
  thursday7amEst.setDate(thursday7amEst.getDate() - daysSinceThursday);

  const boundaries = [];
  for(let i=0; i<5; i++) {
    const d = new Date(thursday7amEst);
    d.setDate(d.getDate() + i);
    boundaries.push(Math.floor(d.getTime()/1000));
  }
  return boundaries; // [Thu7AM, Fri7AM, Sat7AM, Sun7AM, Mon7AM]
}

// Determine current phase & tournament started/ended status
function getCurrentPhase() {
  const [thu, fri, sat, sun, mon] = getESTDayBounds();
  const nowUtcSec = Math.floor(Date.now()/1000);

  if (nowUtcSec < thu) return { phase:'pre-tournament', daysToSum: [], cutoffActive:false, todayWindowStart: null, todayWindowEnd: null };
  if (nowUtcSec < fri) return { phase:'thursday', daysToSum: ['thursday'], cutoffActive:false };
  if (nowUtcSec < sat) return { phase:'friday', daysToSum: ['thursday','friday'], cutoffActive:false };
  if (nowUtcSec < sun) return { phase:'saturday', daysToSum: ['thursday','friday','saturday'], cutoffActive:true };
  if (nowUtcSec < mon) return { phase:'sunday', daysToSum: ['thursday','friday','saturday','sunday'], cutoffActive:true };
  return { phase:'finished', daysToSum: ['thursday','friday','saturday','sunday'], cutoffActive:true };
}

// Bucket karmafeed by day name
function bucketKarmaByDay(karmafeed) {
  const [thu, fri, sat, sun, mon] = getESTDayBounds();
  const scores = { thursday:0, friday:0, saturday:0, sunday:0 };
  if (!Array.isArray(karmafeed)) return scores;
  for(const entry of karmafeed) {
    const ts = entry.timestamp;
    const delta = Number(entry.karmaDelta) || 0;
    if (ts >= thu && ts < fri) scores.thursday += delta;
    else if (ts >= fri && ts < sat) scores.friday += delta;
    else if (ts >= sat && ts < sun) scores.saturday += delta;
    else if (ts >= sun && ts < mon) scores.sunday += delta;
  }
  Object.keys(scores).forEach(k => scores[k] = Math.round(scores[k]));
  return scores;
}

// Bucket karmafeed for today only (7AMâ€“7AM EST day window)
function bucketKarmaToday(karmafeed) {
  if (!Array.isArray(karmafeed)) return 0;
  const now = new Date();
  const nowEst = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
  const today7amEst = new Date(nowEst);
  today7amEst.setHours(7,0,0,0);
  let start, end;

  if (nowEst >= today7amEst) {
    start = Math.floor(today7amEst.getTime()/1000);
    end = start + 86400; // +1 day in seconds
  } else {
    // Before 7AM, today window is previous day 7AM to today 7AM
    end = Math.floor(today7amEst.getTime()/1000);
    start = end - 86400;
  }

  let sum = 0;
  for(const entry of karmafeed) {
    const ts = entry.timestamp;
    const delta = Number(entry.karmaDelta) || 0;
    if (ts >= start && ts < end) sum += delta;
  }
  return Math.round(sum);
}

// Median calculation
function calculateMedian(arr) {
  if (!arr.length) return 0;
  const sorted = arr.map(u => u.sum).sort((a,b)=>a-b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid-1] + sorted[mid]) / 2;
  } else {
    return sorted[mid];
  }
}

// Limited concurrency async map
async function limitedMap(array, limit, asyncFn, onProgress) {
  const results = [];
  let index = 0;
  const executing = new Set();
  for (const item of array) {
    const p = asyncFn(item).then(res => {
      results.push(res);
      if (onProgress) onProgress(++index, array.length);
    });
    executing.add(p);
    p.finally(() => executing.delete(p));
    if (executing.size >= limit) await Promise.race(executing);
  }
  await Promise.all(executing);
  return results;
}

// Fetch karmafeed JSON from Worker for userId
async function fetchKarmaFeed(userId) {
  try {
    const res = await fetch(`${WORKER_URL}?userId=${encodeURIComponent(userId)}`);
    if (!res.ok) return null;
    const data = await res.json();
    return data?.karmafeed || [];
  } catch {
    return null;
  }
}

// Main load function
async function loadLeaderboard() {
  const loading = document.getElementById('loading-indicator');
  const container = document.getElementById('leaderboard');
  container.innerHTML = '';
  loading.textContent = 'Loading users CSV...';

  try {
    // 1. Fetch user CSV
    const csvRes = await axios.get(CSV_URL);
    const users = parseCSV(csvRes.data)
      .filter(u => u.status?.toLowerCase() === 'active')
      .map(u => ({
        userAt: u['user @'],
        userId: u['user id'],
        seed: u.seed.trim().toLowerCase(),
        scores: { thursday: 0, friday: 0, saturday: 0, sunday: 0 },
        sum: 0,
        qualified: false,
      }));

    loading.textContent = `Fetching karma for ${users.length} users...`;

    let loadedCount = 0;
    await limitedMap(users, CONCURRENCY, async user => {
      const feed = await fetchKarmaFeed(user.userId);
      user.karmafeed = feed || [];
      loadedCount++;
      loading.textContent = `Loaded karma for ${loadedCount} / ${users.length} users...`;
      return user;
    });

    const phaseInfo = getCurrentPhase();

    // Pre-tournament: show today's karma only, no sums, no cutoff
    if (phaseInfo.phase === 'pre-tournament') {
      users.forEach(u => {
        u.sum = bucketKarmaToday(u.karmafeed);
        u.qualified = true; // all show
      });
      // Sort all by today's karma descending
      users.sort((a,b) => b.sum - a.sum || a.userAt.localeCompare(b.userAt));

      // Render all users in single leaderboard (no brackets)
      let html = `<div class="bracket"><h2>Pre-Tournament Leaderboard (Today's Karma)</h2>`;
      html += `<table><thead><tr><th>Rank</th><th>User</th><th>Karma</th></tr></thead><tbody>`;
      let rank = 0;
      for (const u of users) {
        rank++;
        html += `<tr><td>${rank}</td><td>@${u.userAt}</td><td>${u.sum}</td></tr>`;
      }
      html += `</tbody></table></div>`;
      container.innerHTML = html;
      loading.textContent = 'Pre-tournament live karma shown.';
      return;
    }

    // Tournament started or ended - full logic

    // Bucket karma by day for each user
    users.forEach(u => {
      u.scores = bucketKarmaByDay(u.karmafeed) || { thursday:0, friday:0, saturday:0, sunday:0 };
    });

    // Calculate sum karma & qualification before cutoff
    users.forEach(u => {
      if (!phaseInfo.cutoffActive) {
        u.sum = phaseInfo.daysToSum.reduce((acc,d) => acc + (u.scores[d]||0), 0);
        u.qualified = true;
      } else {
        // After cutoff: sum Thu+Fri for median calc first
        u.sum = (u.scores.thursday||0) + (u.scores.friday||0);
        u.qualified = false;
      }
    });

    // After cutoff: calculate median and mark qualified
    if (phaseInfo.cutoffActive) {
      // Separate by seed brackets
      const amatuer = users.filter(u => u.seed === 'amatuer');
      const pro = users.filter(u => u.seed === 'pro');

      // Calc median by bracket on Thu+Fri sum
      const amatuerMedian = calculateMedian(amatuer);
      const proMedian = calculateMedian(pro);

      amatuer.forEach(u => {
        u.qualified = u.sum > amatuerMedian;
      });
      pro.forEach(u => {
        u.qualified = u.sum > proMedian;
      });

      // Now sum full days (Thu-Sun) only for qualified users
      users.forEach(u => {
        if (u.qualified) {
          u.sum = phaseInfo.daysToSum.reduce((acc,d) => acc + (u.scores[d]||0), 0);
        } else {
          u.sum = 0; // eliminated users show zero
        }
      });
    }

    // Sort each bracket by sum descending, then username ascending
    const amatuerUsers = users.filter(u => u.seed === 'amatuer').sort((a,b) => b.sum - a.sum || a.userAt.localeCompare(b.userAt));
    const proUsers = users.filter(u => u.seed === 'pro').sort((a,b) => b.sum - a.sum || a.userAt.localeCompare(b.userAt));

    // Render bracket tables
    function renderBracket(title, arr) {
      let html = `<div class="bracket"><h2>${title}</h2>`;
      html += `<table><thead><tr><th>Rank</th><th>User</th><th>Karma</th></tr></thead><tbody>`;
      let rank = 0;
      for (const u of arr) {
        rank++;
        html += `<tr${u.qualified ? '' : ' style="opacity:0.4"'}><td>${rank}</td><td>@${u.userAt}</td><td>${u.sum}</td></tr>`;
      }
      html += `</tbody></table></div>`;
      return html;
    }

    container.innerHTML = renderBracket('Amateur Bracket', amatuerUsers) + renderBracket('Pro Bracket', proUsers);

    loading.textContent = `Loaded ${users.length} users.`;

  } catch (e) {
    console.error(e);
    document.getElementById('loading-indicator').textContent = 'Failed to load leaderboard.';
  }
}

// Initial load and auto-refresh every 5 minutes
loadLeaderboard();
setInterval(loadLeaderboard, 300000);
</script>
</body>
</html>
